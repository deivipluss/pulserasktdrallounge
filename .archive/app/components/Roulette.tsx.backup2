'use client';

// Extendemos el objeto Window para las propiedades globales personalizadas
declare global {
  interface Window {
    __forcedRewardIndex?: number | null;
    __selectedReward?: any;
  }
}

import React, { useEffect, useMemo, useRef, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// Tipos y configuraciÃ³n 
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
export interface Reward {
  id: number;
  name: string;
  probability: number;
  color: string;
  textColor?: string;
  sparkle?: boolean;
  retry?: boolean;
  emoji?: string;
}

// ConfiguraciÃ³n de premios con emojis distintivos para mejor identificaciÃ³n visual
const DEFAULT_REWARDS: Reward[] = [
  { id: 1, name: 'Trident', emoji: 'ğŸ¬', probability: 0.145, color: '#FF4D8D', textColor: '#FFFFFF' },
  { id: 2, name: 'Cigarrillos', emoji: 'ğŸš¬', probability: 0.145, color: '#9B4DFF', textColor: '#FFFFFF' },
  { id: 3, name: 'Cerebritos', emoji: 'ğŸ­', probability: 0.145, color: '#4D9EFF', textColor: '#FFFFFF' },
  { id: 4, name: 'Popcorn', emoji: 'ğŸ¿', probability: 0.145, color: '#31D2F2', textColor: '#000000' },
  { id: 5, name: 'Agua', emoji: 'ğŸ’§', probability: 0.145, color: '#4DFFB8', textColor: '#003B2A' },
  { id: 6, name: 'Chupetines', emoji: 'ğŸ­', probability: 0.245, color: '#FFD93D', textColor: '#5F3A00' },
  { id: 7, name: 'Un Nuevo Intento', emoji: 'ğŸ”„', probability: 0.03, color: '#FB923C', textColor: '#000000', sparkle: true, retry: true },
];

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// Utilidades
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
const norm = (deg: number) => ((deg % 360) + 360) % 360;
const px = (v: number) => `${Math.round(v)}px`;

// SelecciÃ³n ponderada de premios
function pickWeighted(rewards: Reward[]): { reward: Reward; index: number } {
  const total = rewards.reduce((s, r) => s + (r.probability || 0), 0) || 1;
  let r = Math.random() * total;
  for (let i = 0; i < rewards.length; i++) {
    r -= rewards[i].probability || 0;
    if (r <= 0) return { reward: rewards[i], index: i };
  }
  return { reward: rewards[rewards.length - 1], index: rewards.length - 1 };
}

// Efecto confetti
function launchConfetti() {
  try {
    const canvasId = '__mini_confetti';
    let canvas = document.getElementById(canvasId) as HTMLCanvasElement | null;
    if (!canvas) {
      canvas = document.createElement('canvas');
      canvas.id = canvasId;
      Object.assign(canvas.style, {
        position: 'fixed', inset: '0', width: '100%', height: '100%', pointerEvents: 'none', zIndex: '9999',
      } as CSSStyleDeclaration);
      document.body.appendChild(canvas);
    }
    const ctx = canvas.getContext('2d');
    const resize = () => { canvas!.width = window.innerWidth; canvas!.height = window.innerHeight; };
    resize();
    const onResize = () => resize();
    window.addEventListener('resize', onResize);

    const w = canvas!.width, h = canvas!.height;
    const pieces = Array.from({ length: 140 }).map(() => ({
      x: Math.random() * w,
      y: -20 - Math.random() * 100,
      vx: -2 + Math.random() * 4,
      vy: 2 + Math.random() * 3,
      size: 4 + Math.random() * 6,
      a: Math.random() * Math.PI,
      vr: -0.1 + Math.random() * 0.2,
      color: `hsl(${Math.floor(Math.random() * 360)}, 80%, 60%)`,
    }));
    let frame = 0;
    const maxFrames = 220;
    function draw() {
      frame++;
      if (!ctx) return;
      ctx.clearRect(0, 0, w, h);
      pieces.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.a += p.vr;
        p.vx *= 0.99;
        p.vy *= 0.99;
        p.vy += 0.08;
        ctx!.save();
        ctx!.translate(p.x, p.y);
        ctx!.rotate(p.a);
        ctx!.fillStyle = p.color;
        ctx!.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
        ctx!.restore();
      });
      if (frame < maxFrames) requestAnimationFrame(draw);
      else {
        window.removeEventListener('resize', onResize);
        document.body.removeChild(canvas!);
      }
    }
    requestAnimationFrame(draw);
  } catch (e) {
    console.error('Error al lanzar confeti:', e);
  }
}

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// Componente Ruleta
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
interface RouletteProps {
  data?: Reward[];
  size?: number;
  duration?: number;
  onResult?: (reward: Reward, index: number) => void;
  disabled?: boolean;
  debug?: boolean;
}

const Roulette: React.FC<RouletteProps> = ({
  data = DEFAULT_REWARDS,
  size: sizeProp,
  duration = 6000,
  onResult,
  disabled = false,
  debug = false,
}) => {
  // Referencias y estado
  const containerRef = useRef<HTMLDivElement>(null);
  const [autoSize, setAutoSize] = useState(300);
  const [rotation, setRotation] = useState(0);
  const [spinning, setSpinning] = useState(false);
  const [reward, setReward] = useState<Reward | null>(null);
  const selectedRewardRef = useRef<{reward: Reward, index: number} | null>(null);
  const forcedIndex = useRef<number | null>(null);
  
  // CÃ¡lculos geomÃ©tricos bÃ¡sicos
  const n = data.length;
  const segment = 360 / n;
  const diameter = sizeProp ?? autoSize;
  const radius = diameter / 2;

  // Autoajuste al tamaÃ±o del contenedor
  useEffect(() => {
    if (sizeProp) return;
    const updateSize = () => {
      if (!containerRef.current) return;
      const container = containerRef.current;
      const maxWidth = container.clientWidth * 0.95;
      const maxHeight = window.innerHeight * 0.7;
      setAutoSize(Math.max(200, Math.min(maxWidth, maxHeight)));
    };
    updateSize();
    window.addEventListener('resize', updateSize);
    return () => window.removeEventListener('resize', updateSize);
  }, [sizeProp]);
  
  // CORRECCIÃ“N: Ajustar el offset del gradiente para alinear correctamente los colores con las etiquetas
  // 1. GeneraciÃ³n del gradiente de color (corregido para alineaciÃ³n perfecta)
  const wheelGradient = useMemo(() => {
    const stops = data.map((reward, i) => {
      const startPct = (i * 100) / n;
      const endPct = ((i + 1) * 100) / n;
      // Esta sintaxis de "doble posiciÃ³n" crea bordes duros y nÃ­tidos entre colores,
      // eliminando el antialiasing del navegador que causa el desfase visual.
      return `${reward.color} ${startPct}% ${endPct}%`;
    });
    // El offset de -90deg asegura que el primer sector comience en la parte superior (12 en punto)
    return `conic-gradient(from -90deg, ${stops.join(', ')})`;
  }, [data, n]);

  // 2. CÃ¡lculo de las lÃ­neas divisorias (CORREGIDO)
  const dividers = useMemo(
    () =>
      // Los separadores deben alinearse con los bordes de los sectores
      // Cada separador debe situarse en: i * segment - 90 (sin el ajuste adicional de -0.5)
      Array.from({ length: n }).map((_, i) => i * segment - 90),
    [n, segment]
  );

  // FunciÃ³n para calcular la rotaciÃ³n objetivo
  const getTargetRotation = (idx: number): number => {
    // ValidaciÃ³n del Ã­ndice
    if (idx < 0 || idx >= data.length) {
      console.error(`[Ruleta] Ãndice invÃ¡lido: ${idx}, usando Ã­ndice 0`);
      idx = 0;
    }
    
    // CÃ¡lculo puramente geomÃ©trico por sector
    const sectorCenter = (idx + 0.5) * segment;
    let base = -sectorCenter;
    
    // Aplicamos vueltas mÃ­nimas para un efecto visual satisfactorio
    const minRotations = 4;
    const currentNormalized = norm(rotation);
    let target = base;

    // Normalizar target a [0,360)
    target = norm(target);

    // Aseguramos que gire al menos las vueltas mÃ­nimas desde la posiciÃ³n actual
    while (target < currentNormalized + 360 * minRotations) {
      target += 360;
    }
    
    return target;
  };

  // Detectar Ã­ndice forzado desde la variable global
  useEffect(() => {
    if (typeof window !== 'undefined') {
      const checkForced = () => {
        if (window.__forcedRewardIndex !== undefined && window.__forcedRewardIndex !== null) {
          forcedIndex.current = window.__forcedRewardIndex;
          window.__forcedRewardIndex = null;
          console.log('[Ruleta] Ãndice forzado recibido:', forcedIndex.current);
        }
      };
      
      const initialCheck = setTimeout(checkForced, 500);
      const intervalCheck = setInterval(checkForced, 300);
      
      return () => {
        clearTimeout(initialCheck);
        clearInterval(intervalCheck);
      };
    }
  }, []);

  // FunciÃ³n para girar la ruleta
  const spin = () => {
    if (spinning || disabled) return;
    
    // Determinar el premio (forzado o aleatorio)
    let selectedIndex: number;
    let selectedReward: Reward;
    
    if (forcedIndex.current !== null) {
      selectedIndex = forcedIndex.current;
      
      if (selectedIndex >= 0 && selectedIndex < data.length) {
        selectedReward = data[selectedIndex];
        console.log(`[Ruleta] Usando premio forzado: ${selectedReward.name} (Ã­ndice ${selectedIndex})`);
      } else {
        console.warn(`[Ruleta] Ãndice forzado invÃ¡lido: ${selectedIndex}, usando selecciÃ³n aleatoria`);
        const result = pickWeighted(data);
        selectedIndex = result.index;
        selectedReward = result.reward;
      }
      
      forcedIndex.current = null;
    } else {
      const result = pickWeighted(data);
      selectedIndex = result.index;
      selectedReward = result.reward;
    }
    
    // IMPORTANTE: Almacenamos la selecciÃ³n original en una referencia estable
    selectedRewardRef.current = {
      reward: selectedReward,
      index: selectedIndex
    };
    
    // TambiÃ©n lo exponemos globalmente para depuraciÃ³n
    if (typeof window !== 'undefined') {
      window.__selectedReward = selectedReward;
    }
    
    // Iniciar animaciÃ³n
    console.log(`[Ruleta] Girando hacia premio: ${selectedReward.name} (Ã­ndice ${selectedIndex})`);
    setSpinning(true);
    
    // Calcular rotaciÃ³n objetivo
    const target = getTargetRotation(selectedIndex);
    setRotation(target);
    
    // Finalizar el giro despuÃ©s de la animaciÃ³n
    window.setTimeout(() => {
      setSpinning(false);
      
      // Usar SIEMPRE el premio almacenado en la referencia, para evitar
      // cualquier posible problema de "race condition" o actualizaciÃ³n de estado
      if (selectedRewardRef.current) {
        const finalReward = selectedRewardRef.current.reward;
        const finalIndex = selectedRewardRef.current.index;
        
        // Establecemos el premio ganador
        setReward(finalReward);
        
        if (finalReward.sparkle) {
          launchConfetti();
        }
        
        console.log(`[Ruleta] Premio final: ${finalReward.name}`);
        onResult?.(finalReward, finalIndex);
      }
    }, duration);
  };

  return (
    <div ref={containerRef} className="relative" suppressHydrationWarning>
      {/* Indicador de premio en la parte superior */}
      <div 
        className="absolute top-0 left-1/2 transform -translate-x-1/2 -translate-y-4 z-20 pointer-events-none"
        suppressHydrationWarning
      >
        <div className="relative">
          {/* TriÃ¡ngulo indicador */}
          <div className="absolute top-0 left-1/2 transform -translate-x-1/2 -translate-y-[15px]">
            <div className="w-0 h-0 
                      border-l-[16px] border-l-transparent
                      border-r-[16px] border-r-transparent
                      border-t-[24px] border-t-amber-500
                      filter drop-shadow-lg"></div>
          </div>

          {/* Base circular */}
          <div className="absolute top-2 left-1/2 transform -translate-x-1/2 -translate-y-[24px]
                       w-8 h-8 rounded-full bg-white border-[3px] border-amber-500 
                       shadow-md z-20"></div>
          
          {/* Texto "PREMIO" */}
          <div className="absolute top-1 left-1/2 transform -translate-x-1/2 translate-y-[6px]
                        bg-amber-500 text-white text-[10px] font-bold px-3 py-0.5 rounded-full
                        shadow-md z-30">PREMIO</div>
          
          {/* Efecto de pulso */}
          <div className="absolute top-2 left-1/2 transform -translate-x-1/2 -translate-y-[24px]
                        w-16 h-8 opacity-0
                        animate-ping rounded-full bg-amber-500/30"></div>
        </div>
      </div>
      
      {/* Contenedor principal de la ruleta */}
      <div
        className="relative mx-auto rounded-full overflow-hidden aspect-square"
        style={{ width: px(diameter), height: px(diameter) }}
        suppressHydrationWarning
      >
        {/* Ruleta giratoria */}
        <motion.div
          className="relative w-full h-full"
          animate={{ rotate: rotation }}
          initial={{ rotate: 0 }} 
          transition={{ 
            duration: duration / 1000, 
            type: 'spring', 
            bounce: 0.1, 
            damping: 15,
            stiffness: 20,
            mass: 1.5
          }}
          suppressHydrationWarning
        >
          {/* Disco de color */}
          <motion.div
            className="w-full h-full"
            style={{
              background: wheelGradient,
              boxShadow: 'inset 0 0 0 8px rgba(255,255,255,0.1)',
            }}
            suppressHydrationWarning
          ></motion.div>

          {/* LÃ­neas divisorias (CORREGIDAS) */}
          {dividers.map((angle, i) => (
            <div
              key={`divider-${i}`}
              className="absolute top-1/2 left-1/2 w-[50%] h-[1px] origin-left bg-white/20 -translate-y-1/2"
              style={{ transform: `translateY(-50%) rotate(${angle}deg)` }}
            />
          ))}

          {/* Etiquetas de premios con emojis (corregidas para alineaciÃ³n) */}
          {data.map((reward, i) => {
            // CORRECCIÃ“N: Ajustamos el Ã¡ngulo para alinear con el nuevo gradiente
            // El centro del sector debe estar en el centro de cada segmento de color
            // Usamos -90Â° porque el gradiente empieza en -90deg (parte superior)
            const angleCenter = (i * segment + segment / 2) - 90; 
            const aFinal = norm(angleCenter);
            const isFlipped = aFinal > 90 && aFinal < 270;
            
            // Calculamos el ancho mÃ¡ximo para la etiqueta
            const labelRadius = radius * 0.68;
            const segRad = (segment * Math.PI) / 180;
            const maxWidth = Math.floor(2 * labelRadius * Math.sin(segRad / 2) * 0.82);

            return (
              <div
                key={`label-${i}`}
                className="absolute left-1/2 top-1/2"
                data-label-index={i}
                style={{ 
                  transform: `rotate(${angleCenter}deg) translate(${px(labelRadius)})`, 
                  transformOrigin: '0 0'
                }}
              >
                <span
                  className="block text-center text-[clamp(10px,1.7vw,18px)] font-semibold leading-tight drop-shadow-[0_1px_2px_rgba(0,0,0,0.6)] break-words whitespace-normal"
                  style={{
                    width: px(maxWidth),
                    transform: `translateX(-50%) rotate(${isFlipped ? 180 : 0}deg)`,
                    color: reward.textColor || '#111',
                  }}
                >
                  {reward.emoji ? `${reward.emoji} ${reward.name}` : reward.name}
                </span>
              </div>
            );
          })}
        </motion.div>

        {/* BotÃ³n central */}
        <div className="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-[28%] h-[28%] rounded-full bg-white/95 border border-white/70 shadow-[inset_0_2px_8px_rgba(0,0,0,0.1),0_8px_24px_rgba(0,0,0,0.2)] flex items-center justify-center" suppressHydrationWarning>
          <button
            onClick={spin}
            disabled={spinning || disabled}
            className="px-5 py-2 rounded-full text-white font-bold disabled:opacity-50 disabled:cursor-not-allowed shadow-[0_10px_30px_rgba(0,0,0,0.35)]"
            style={{ background: 'linear-gradient(180deg,#f59e0b,#ea580c)' }}
          >
            {spinning ? 'Girandoâ€¦' : 'Girar'}
          </button>
        </div>
      </div>

      {/* InformaciÃ³n de probabilidades */}
      <AnimatePresence>
        {!spinning && (
          <motion.div
            initial={{ opacity: 0, y: 8 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -6 }}
            className="mt-4 text-center text-sm text-white/90"
          >
            <div className="opacity-80" suppressHydrationWarning>
              {`Probabilidades: Chupetines ${Math.round((data.find(d=>d.name==='Chupetines')?.probability||0)*100)}%, Nuevo intento ${Math.round((data.find(d=>d.retry)?.probability||0)*100)}%`}
            </div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Panel de premio ganador */}
      {spinning === false && reward && (
        <motion.div 
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.3 }}
          className="mt-6 py-3 px-4 rounded-lg bg-gradient-to-r from-amber-50 to-amber-100 
                     dark:from-amber-900/50 dark:to-amber-800/50
                     border border-amber-200 dark:border-amber-700
                     shadow-lg text-center"
          suppressHydrationWarning
        >
          <div className="text-sm opacity-70 mb-1">Â¡Premio ganador!</div>
          <div 
            className="text-xl font-bold" 
            style={{ 
              color: reward.color, 
              textShadow: '0 1px 2px rgba(0,0,0,0.2)',
              padding: '4px 8px',
              borderRadius: '4px',
              backgroundColor: `${reward.color}20`
            }}
          >
            {reward.emoji ? `${reward.emoji} ${reward.name}` : reward.name}
          </div>
          <div className="text-xs mt-2 opacity-80">
            {reward.retry ? 'Â¡Puedes volver a girar!' : 'Reclama tu premio con un organizador'}
          </div>
        </motion.div>
      )}
    </div>
  );
};

'use client';

// ... existing code ...

export default Roulette;

import React, { useEffect, useMemo, useRef, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// Tipos y configuraciÃ³n (traÃ­dos de V1)
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
export interface Reward {
  id: number; // Ã­ndice (1-based)
  name: string; // etiqueta visible
  probability: number; // peso relativo (suma â‰ˆ 1)
  color: string; // color de segmento
  textColor?: string; // color del texto del label
  sparkle?: boolean; // efecto confetti al ganar
  retry?: boolean; // semÃ¡ntica de "nuevo intento"
}

// Mismo orden, colores y distribuciÃ³n de V1
const DEFAULT_REWARDS_V1: Reward[] = [
  { id: 1, name: 'Trident',       probability: 0.145, color: '#FF4D8D', textColor: '#FFFFFF' },
  { id: 2, name: 'Cigarrillos',   probability: 0.145, color: '#9B4DFF', textColor: '#FFFFFF' },
  { id: 3, name: 'Cerebritos',    probability: 0.145, color: '#4D9EFF', textColor: '#FFFFFF' },
  { id: 4, name: 'Popcorn',       probability: 0.145, color: '#31D2F2', textColor: '#000000' },
  { id: 5, name: 'Agua',          probability: 0.145, color: '#4DFFB8', textColor: '#003B2A' },
  { id: 6, name: 'Chupetines',    probability: 0.245, color: '#FFD93D', textColor: '#5F3A00' },
  { id: 7, name: 'Un Nuevo Intento', probability: 0.03, color: '#FB923C', textColor: '#000000', sparkle: true, retry: true },
];

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// Utilidades (ponderaciÃ³n V1 + geometrÃ­a V2)
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
const clamp = (v: number, a: number, b: number) => Math.max(a, Math.min(b, v));
const norm = (deg: number) => ((deg % 360) + 360) % 360;

function pickWeighted(rewards: Reward[]): { reward: Reward; index: number } {
  const total = rewards.reduce((s, r) => s + (r.probability || 0), 0) || 1;
  let r = Math.random() * total;
  for (let i = 0; i < rewards.length; i++) {
    r -= rewards[i].probability || 0;
    if (r <= 0) return { reward: rewards[i], index: i };
  }
  return { reward: rewards[rewards.length - 1], index: rewards.length - 1 };
}

// Confetti liviano (traÃ­do y simplificado de V1)
function launchConfetti() {
  try {
    const canvasId = '__mini_confetti';
    let canvas = document.getElementById(canvasId) as HTMLCanvasElement | null;
    if (!canvas) {
      canvas = document.createElement('canvas');
      canvas.id = canvasId;
      Object.assign(canvas.style, {
        position: 'fixed', inset: '0', width: '100%', height: '100%', pointerEvents: 'none', zIndex: '9999',
      } as CSSStyleDeclaration);
      document.body.appendChild(canvas);
    }
    const ctx = canvas.getContext('2d');
    const resize = () => { canvas!.width = window.innerWidth; canvas!.height = window.innerHeight; };
    resize();
    const onResize = () => resize();
    window.addEventListener('resize', onResize);

    const w = canvas!.width, h = canvas!.height;
    const pieces = Array.from({ length: 140 }).map(() => ({
      x: Math.random() * w,
      y: -20 - Math.random() * 100,
      vx: -2 + Math.random() * 4,
      vy: 2 + Math.random() * 3,
      size: 4 + Math.random() * 6,
      a: Math.random() * Math.PI,
      vr: -0.1 + Math.random() * 0.2,
      color: `hsl(${Math.floor(Math.random() * 360)}, 80%, 60%)`,
    }));
    let frame = 0;
    const maxFrames = 220;
    function draw() {
      frame++;
      if (!ctx) return;
      ctx.clearRect(0, 0, w, h);
      for (const p of pieces) {
        p.x += p.vx; p.y += p.vy; p.a += p.vr;
        ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.a);
        ctx.fillStyle = p.color; ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
        ctx.restore();
      }
      if (frame < maxFrames) requestAnimationFrame(draw); else {
        window.removeEventListener('resize', onResize);
        canvas?.remove();
      }
    }
    requestAnimationFrame(draw);
  } catch { /* noop */ }
}

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// Props del componente unificado
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
interface RouletteUnifiedProps {
  rewards?: Reward[]; // si no se pasa, usa DEFAULT_REWARDS_V1
  onResult?: (reward: Reward, index: number) => void;
  size?: number; // si no se define, se autoajusta al contenedor
  fixedSectors?: number; // normalmente 7
  durationMs?: number; // V1 â‰ˆ 5200ms
  disabled?: boolean;
  debug?: boolean; // imprime tabla de Ã¡ngulos y guÃ­a visual
}

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// Componente principal (geometrÃ­a V2 + reglas V1)
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
const RouletteUnified: React.FC<RouletteUnifiedProps> = ({
  rewards = DEFAULT_REWARDS_V1,
  onResult,
  size,
  fixedSectors = 7,
  durationMs = 5200,
  disabled = false,
  debug = false,
}) => {
  // NormalizaciÃ³n exacta del nÃºmero de sectores (estilo V2)
  const data = useMemo<Reward[]>(() => {
    const src = Array.isArray(rewards) && rewards.length > 0 ? rewards : DEFAULT_REWARDS_V1;
    if (fixedSectors && fixedSectors > 0) {
      const out: Reward[] = [];
      for (let i = 0; i < fixedSectors; i++) out.push(src[i % src.length]);
      return out;
    }
    return src;
  }, [rewards, fixedSectors]);

  const n = data.length;
  const segment = 360 / n;

  // Responsivo (si no hay size explÃ­cito)
  const containerRef = useRef<HTMLDivElement | null>(null);
  const [autoSize, setAutoSize] = useState<number>(420);
  useEffect(() => {
    if (size) return; // si viene fijo no observar
    const el = containerRef.current; if (!el) return;
    const ro = new ResizeObserver((entries) => {
      for (const e of entries) {
        const w = (e.contentBoxSize as any)?.[0]?.inlineSize || e.contentRect.width || el.clientWidth;
        setAutoSize(clamp(Math.floor(w), 260, 560));
      }
    });
    ro.observe(el);
    return () => ro.disconnect();
  }, [size]);

  const diameter = size ?? autoSize;
  const radius = diameter / 2;

  // Estado de animaciÃ³n (estilo V2)
  const [rotation, setRotation] = useState(0);
  const [spinning, setSpinning] = useState(false);
  const lastTarget = useRef(0);
  
  // Estado y estilos para el modo debug
  const [showDebugOverlay, setShowDebugOverlay] = useState(debug);
  
  // Utilidades de depuraciÃ³n para visualizar la alineaciÃ³n de los sectores
  useEffect(() => {
    if (debug) {
      console.log(`[RULETA DEBUG] ${n} sectores de ${segment}Â° cada uno`);
      console.log(`[RULETA DEBUG] Premios configurados:`, data.map((r, i) => `${i}: ${r.name}`).join(', '));
    }
  }, [debug, n, segment, data]);

  // En CSS conic-gradient 0deg ya apunta a las 12 en punto, asÃ­ que OFFSET=0
  const OFFSET = 0;
  
  // ConfiguraciÃ³n de alineaciÃ³n
  const WHEEL_CONFIG = {
    SECTOR_ORDER: "CLOCKWISE", // Los sectores se dibujan en CSS en sentido horario
    ROTATION_DIR: "COUNTERCLOCKWISE", // La rueda gira en sentido antihorario (rotaciÃ³n negativa)
    POINTER_POSITION: "TOP", // El puntero estÃ¡ arriba (0Â°)
    STARTING_INDEX: 0, // El Ã­ndice 0 comienza arriba (0Â°)
    VERBOSE_DEBUG: debug // Activar logs detallados
  };

  // REDISEÃ‘O DE GEOMETRÃA
  // - Wheel: CSS conic-gradient dibuja sectores en sentido HORARIO desde 0deg (arriba)
  // - RotaciÃ³n: Giramos en sentido ANTIHORARIO (valores negativos de rotaciÃ³n)
  // - AlineaciÃ³n: El Ã­ndice 0 (Trident) debe quedar exactamente arriba (0Â°)
  const wheelGradient = useMemo(() => {
    const stops: string[] = [];
    for (let i = 0; i < n; i++) {
      const color = data[i].color ?? `hsl(${(i * 360) / n}, 70%, 50%)`;
      const start = i * segment;
      const end = (i + 1) * segment;
      stops.push(`${color} ${start}deg ${end}deg`);
    }
    return `conic-gradient(from 0deg, ${stops.join(', ')})`;
  }, [n, segment, data]);

  // LÃ­neas divisorias - seguimos el mismo orden del gradiente
  const dividers = useMemo(() => Array.from({ length: n }).map((_, i) => i * segment), [n, segment]);

  // Ãngulo objetivo para que el CENTRO del sector quede en el puntero (12h)
  const getTargetRotation = (idx: number) => {
    // CORREGIDO: El offset del 0.5 estaba causando el problema
    // Puntero estÃ¡ arriba (0Â°) y queremos que apunte al centro del sector ganador
    const thetaCenter = (idx * segment) + (segment / 2); // centro exacto del sector
    
    // RotaciÃ³n necesaria para llevar el centro del premio al puntero (12h)
    // Negativo porque giramos en sentido antihorario
    const base = -thetaCenter;
    
    // AÃ±adimos mÃºltiples vueltas para efecto visual
    const finalRotation = base - (360 * 3);
    
    // Debug para verificar alineaciÃ³n
    console.log(`[WHEEL DEBUG] Premio: ${idx} (${data[idx]?.name}), RotaciÃ³n: ${finalRotation}Â°`);
    return finalRotation;
  };

  // FunciÃ³n debug para forzar un Ã­ndice especÃ­fico (QA)
  const forceSpin = (forceIndex: number) => {
    if (spinning || disabled) return;
    if (forceIndex < 0 || forceIndex >= data.length) return;
    
    console.log(`[RULETA] Forzando premio con Ã­ndice ${forceIndex}: ${data[forceIndex]?.name}`);
    
    setSpinning(true);
    const target = getTargetRotation(forceIndex);
    lastTarget.current = target;
    setRotation(target);
    
    window.setTimeout(() => {
      setSpinning(false);
      // Efectos V1
      try { if ('vibrate' in navigator) (navigator as any).vibrate?.(70); } catch {}
      const reward = data[forceIndex];
      if (reward.sparkle) launchConfetti();
      
      // VerificaciÃ³n visual similar a spin()
      const finalRot = norm(target);
      const pointerAngle = norm(-finalRot);
      const sectorIndex = Math.floor(pointerAngle / segment);
      const visualIndex = sectorIndex % n;
      const visualReward = data[visualIndex];
      
      // Verificamos que coincidan
      if (visualIndex !== forceIndex) {
        console.error(`[RULETA ERROR] Forzado: Discrepancia entre Ã­ndice forzado (${forceIndex}: ${reward.name}) y visual (${visualIndex}: ${visualReward?.name})`);
      }
      
      // SIEMPRE usamos el premio visual como fuente de verdad
      onResult?.(visualReward || reward, visualIndex);
      
      console.log(`[RULETA DEBUG] Forzado premio: ${reward.name} (Ã­ndice ${forceIndex}) - Visual: ${visualReward?.name} (${visualIndex})`);
    }, durationMs);
  };

  // Exponer forceSpin para depuraciÃ³n
  React.useEffect(() => {
    (window as any).__rouletteForceSpin = (idx: number) => forceSpin(idx);
    return () => { delete (window as any).__rouletteForceSpin; };
  }, [data, durationMs, spinning, disabled]);

  // Spin usando la selecciÃ³n ponderada de V1
  const spin = () => {
    if (spinning || disabled) return;
    
    // Seleccionamos el premio mediante la funciÃ³n de peso
    const { reward, index } = pickWeighted(data);
    
    // IMPORTANTE: Este Ã­ndice es ahora el Ã­ndice LOGICO del premio seleccionado
    console.log(`[RULETA] Premio seleccionado: ${reward.name} (Ã­ndice ${index})`);
    
    // Iniciamos la animaciÃ³n
    setSpinning(true);
    
    // Calculamos la rotaciÃ³n necesaria para que el sector elegido quede bajo el puntero
    const target = getTargetRotation(index);
    lastTarget.current = target;
    setRotation(target);

    // Esperamos a que termine la animaciÃ³n
    window.setTimeout(() => {
      setSpinning(false);
      
      // Efectos cuando termina el giro
      try { if ('vibrate' in navigator) (navigator as any).vibrate?.(70); } catch {}
      if (reward.sparkle) launchConfetti();
      
      // Verificamos visualmente quÃ© premio quedÃ³ bajo el puntero
      const finalRot = norm(target);
      const pointerAngle = norm(-finalRot);
      const sectorIndex = Math.floor(pointerAngle / segment);
      const visualIndex = sectorIndex % n;
      
      // IMPORTANTE: El premio visual debe coincidir con el premio lÃ³gico
      const visualReward = data[visualIndex];
      
      // Verificamos que coincidan
      if (visualIndex !== index) {
        console.error(`[RULETA ERROR] Discrepancia entre premio lÃ³gico (${index}: ${reward.name}) y visual (${visualIndex}: ${visualReward?.name})`);
      }
      
      // Reportamos el premio seleccionado (usando el premio VISUAL como fuente de verdad)
      onResult?.(visualReward || reward, visualIndex);
      
      // Debug adicional
      if ((window as any).__rouletteDebugHook) {
        (window as any).__rouletteDebugHook({
          expectedIndex: index,
          visualIndex,
          actualReward: reward,
          pointerAngle,
          segment,
          rewardName: reward.name,
          expectedName: data[index].name,
          visualName: visualReward?.name,
          finalRotation: finalRot
        });
      }
    }, durationMs);
  };

  // Debug: tabla de Ã¡ngulos visibles mejorada
  useEffect(() => {
    if (!debug) return;
    
    // Mostramos sectores con Ã­ndices y Ã¡ngulos
    const sectorInfo = data.map((p, i) => ({
      index: i,
      name: p.name,
      startAngle: norm(i * segment),
      centerAngle: norm((i + 0.5) * segment),
      endAngle: norm((i + 1) * segment),
      color: p.color,
      probability: p.probability || 0
    }));
    
    console.log("=== RULETA: MAPA DE SECTORES ===");
    console.table(sectorInfo);
    
    // Mostrar informaciÃ³n de cÃ³mo calcular el premio visualmente
    console.log("=== RULETA: GUÃA DE INTERPRETACIÃ“N ===");
    console.log("1. El puntero estÃ¡ arriba (0Â°)");
    console.log("2. La rueda gira en sentido ANTIHORARIO (rotaciÃ³n negativa)");
    console.log("3. El Ã­ndice 0 estÃ¡ inicialmente en la parte superior");
    console.log("4. La rotaciÃ³n final determina quÃ© premio queda bajo el puntero");
    console.log("5. Para determinar el sector desde una rotaciÃ³n final:");
    console.log("   - Normalizar la rotaciÃ³n: (rot % 360 + 360) % 360");
    console.log("   - Calcular Ã¡ngulo del puntero: norm(-rotaciÃ³n)");
    console.log("   - Calcular sector: Math.floor(Ã¡ngulo / segment)");
    
  }, [debug, data, segment]);

  // Helpers de estilo
  const px = (v: number) => `${v}px`;

  return (
    <div ref={containerRef} className="w-full flex flex-col items-center select-none" style={{ minHeight: px(diameter + 120) }}>
      <div className="relative" style={{ width: px(diameter), height: px(diameter) }}>
        {/* Controles de debug */}
        {debug && (
          <div className="absolute top-[-30px] left-0 flex items-center gap-2 z-30 bg-black/50 text-white px-2 py-1 rounded">
            <button 
              onClick={() => setShowDebugOverlay(!showDebugOverlay)}
              className="px-2 py-1 bg-blue-500 rounded text-xs"
            >
              {showDebugOverlay ? "Ocultar Debug" : "Mostrar Debug"}
            </button>
            <span className="text-xs">RotaciÃ³n: {Math.round(rotation)}Â°</span>
          </div>
        )}
        
        {/* Marcador superior (puntero hacia abajo) */}
        <div className="absolute top-0 left-1/2 -translate-x-1/2 -translate-y-[22%] z-20">
          <div className="relative w-[30px] h-[45px] flex items-center justify-center">
            <svg viewBox="0 0 24 24" className="w-[26px] h-[36px] drop-shadow-lg">
              <path d="M12 22 L4 8 H20 Z" fill="#fb923c" />
            </svg>
            <div className="absolute top-[-6px] w-[10px] h-[10px] bg-[#fb923c] rounded-full" />
          </div>
        </div>

        {/* Wrapper con OFFSET fijo a -90Â° (mueve el 0Â° del gradiente a 12 en punto) */}
        <motion.div
          className="absolute inset-0 rounded-full"
        >
          {/* Disco que gira */}
          <motion.div
            className="absolute inset-0 rounded-full border border-white/15 shadow-[0_12px_40px_rgba(0,0,0,0.35)]"
            style={{ background: wheelGradient, willChange: 'transform' }}
            animate={{ rotate: rotation }}
            transition={{ duration: durationMs / 1000, ease: [0.2, 0.8, 0.2, 1] }}
          >
            {/* Separadores precisos */}
            {dividers.map((deg, i) => (
              <div
                key={`divider-${i}`}
                className="absolute left-1/2 top-1/2"
                style={{ transform: `translate(-50%, -50%) rotate(${deg}deg)`, transformOrigin: '50% 50%' }}
              >
                <div
                  className="absolute bg-white/90"
                  style={{
                    left: '50%',
                    top: '50%',
                    width: '1.5px',
                    height: px(radius * 0.92),
                    transform: 'translate(-50%, -100%)',
                    transformOrigin: 'center bottom',
                  }}
                />
                
                {/* Ãndices de sector visibles en modo debug */}
                {debug && showDebugOverlay && (
                  <div 
                    className="absolute text-white bg-black/80 px-1 rounded-sm z-10"
                    style={{
                      left: '50%',
                      top: '10%',
                      transform: 'translate(-50%, 0)',
                      fontSize: '10px',
                    }}
                  >
                    {i}
                  </div>
                )}
              </div>
            ))}

            {/* Etiquetas radiales (con flip para lado izquierdo) */}
            {data.map((reward, i) => {
              // Invertimos el Ã­ndice para mantener la consistencia visual-lÃ³gica
              // AsÃ­ el Ã­ndice 0 queda arriba, igual que en el gradiente
              const visualIndex = (n - i) % n;
              const angleCenter = (visualIndex + 0.5) * segment;
              const aFinal = norm(angleCenter); // para decidir flip ya en la escena final
              const isFlipped = aFinal > 90 && aFinal < 270;

              const labelRadius = radius * 0.68;
              const segRad = (segment * Math.PI) / 180;
              const maxWidth = Math.floor(2 * labelRadius * Math.sin(segRad / 2) * 0.82);

              return (
                <div
                  key={`label-${i}`}
                  className="absolute left-1/2 top-1/2"
                  style={{ transform: `rotate(${angleCenter}deg) translate(${px(labelRadius)})`, transformOrigin: '0 0' }}
                >
                  <span
                    className="block text-center text-[clamp(10px,1.7vw,18px)] font-semibold leading-tight drop-shadow-[0_1px_2px_rgba(0,0,0,0.6)] break-words whitespace-normal"
                    style={{
                      width: px(maxWidth),
                      transform: `translateX(-50%) rotate(${isFlipped ? 180 : 0}deg)`,
                      color: reward.textColor || '#111',
                    }}
                  >
                    {reward.name}
                  </span>
                </div>
              );
            })}
          </motion.div>

          {/* Centro / botÃ³n */}
          <div className="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-[28%] h-[28%] rounded-full bg-white/95 border border-white/70 shadow-[inset_0_2px_8px_rgba(0,0,0,0.1),0_8px_24px_rgba(0,0,0,0.2)] flex items-center justify-center">
            <button
              onClick={spin}
              disabled={spinning || disabled}
              className="px-5 py-2 rounded-full text-white font-bold disabled:opacity-50 disabled:cursor-not-allowed shadow-[0_10px_30px_rgba(0,0,0,0.35)]"
              style={{ background: 'linear-gradient(180deg,#f59e0b,#ea580c)' }}
            >
              {spinning ? 'Girandoâ€¦' : 'Girar'}
            </button>
          </div>
        </motion.div>
      </div>

      {/* MensajerÃ­a opcional (retry / sparkle) */}
      <AnimatePresence>
        {!spinning && (
          <motion.div
            initial={{ opacity: 0, y: 8 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -6 }}
            className="mt-4 text-center text-sm text-white/90"
          >
            <div className="opacity-80">{`Probabilidades cargadas como en V1 (Chupetines ${Math.round((data.find(d=>d.name==='Chupetines')?.probability||0)*100)}%, Nuevo intento ${Math.round((data.find(d=>d.retry)?.probability||0)*100)}%).`}</div>
          </motion.div>
        )}
      </AnimatePresence>

      {debug && (
        <div className="mt-4 text-xs text-white/80 font-mono grid grid-cols-3 gap-x-4 gap-y-1">
          {data.map((r, i) => (
            <React.Fragment key={`dbg-${i}`}>
              <div>#{i + 1} {r.name}</div>
              <div>start: {Math.round(norm(i * segment))}Â°</div>
              <div>end: {Math.round(norm((i + 1) * segment))}Â°</div>
            </React.Fragment>
          ))}
        </div>
      )}
    </div>
  );
};

export default RouletteUnified;

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// Dev harness opcional (para pruebas locales)
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
export const RouletteUnifiedDev: React.FC = () => {
  const [last, setLast] = useState<Reward | null>(null);
  return (
    <div className="w-full flex flex-col items-center gap-4 p-4">
      <RouletteUnified debug onResult={(r)=>setLast(r)} />
      <div className="text-white/90 text-sm">Ãšltimo premio: <b>{last?.name ?? '(aÃºn ninguno)'}</b></div>
    </div>
  );
};
